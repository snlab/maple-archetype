/*
 * Copyright (c) 2016 SNLAB and others.  All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 */
package org.opendaylight.maple.impl.odlmaple.flow;

import com.google.common.base.*;
import org.maple.core.increment.MapleDataPathAdaptor;
import org.maple.core.increment.tracetree.*;
import org.opendaylight.controller.md.sal.binding.api.DataBroker;
import org.opendaylight.controller.md.sal.binding.api.ReadOnlyTransaction;
import org.opendaylight.controller.md.sal.binding.api.WriteTransaction;
import org.opendaylight.controller.md.sal.common.api.data.LogicalDatastoreType;
import org.opendaylight.controller.md.sal.common.api.data.ReadFailedException;
import org.opendaylight.controller.md.sal.common.api.data.TransactionCommitFailedException;
import org.opendaylight.maple.impl.odlmaple.data.InventoryReader;
import org.opendaylight.maple.impl.odlmaple.flow.FlowInfoKey;
import org.opendaylight.maple.impl.odlmaple.utils.FlowUtils;
import org.opendaylight.maple.impl.odlmaple.utils.Maple2ODLUtils;
import org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.inet.types.rev100924.Uri;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.FlowId;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.tables.Table;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.tables.TableKey;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.tables.table.Flow;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.tables.table.FlowBuilder;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.OutputPortValues;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.flow.Match;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.*;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.node.NodeConnector;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.node.NodeConnectorKey;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.nodes.Node;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.nodes.NodeKey;
import org.opendaylight.yang.gen.v1.urn.opendaylight.packet.service.rev130709.PacketProcessingService;
import org.opendaylight.yang.gen.v1.urn.opendaylight.packet.service.rev130709.TransmitPacketInput;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.TpId;
import org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns.yang.network.topology.rev131021.network.topology.Topology;
import org.opendaylight.yangtools.yang.binding.InstanceIdentifier;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.*;
import java.util.concurrent.ExecutionException;

import static org.opendaylight.maple.impl.odlmaple.utils.FlowUtils.*;
import static org.opendaylight.maple.impl.odlmaple.utils.InstanceIdentifierUtils.*;
import static org.opendaylight.maple.impl.odlmaple.utils.Maple2ODLUtils.setODLMatch;


public class FlowManager implements MapleDataPathAdaptor{
    private static final Logger LOG = LoggerFactory.getLogger(FlowManager.class);
    private Map<String, Set<NodeConnectorRef>> nodeKey2ncrs;
    private DataBroker fastDataStore;
    public int flowPriority;
    private static final Short DEFAULT_TABLE_ID = 0;
    private TableKey tableKey = new TableKey(flowTableId);
   // private FlowId flowId = new FlowId(String.valueOf(flowIdInc.getAndIncrement()));
    private PacketProcessingService packetProcessingService;
    private Map<FlowInfoKey, InstanceIdentifier<Flow>> flowInfo;

    public FlowManager(DataBroker fastDataStore, PacketProcessingService pps) {
        this.packetProcessingService = pps;
        this.fastDataStore = fastDataStore;
        flowInfo = new HashMap<>();
        LOG.info("Maple FlowManager construt successfully");
    }

    /**
     * Send packet-out message
     *
     * @param payload
     * @param ingress
     * @param action
     */
    @Override
    public void sendPacket(byte[] payload, NodeConnectorRef ingress, Action action) {
        if (action instanceof Flood) {
            sendFloodPacket(payload, ingress);

        } else if (action instanceof Path) {

            sendPathPacket(payload, ingress, action);
        }
    }

    /**
     * Send path packet-out message
     *
     * @param payload
     * @param ingress
     * @param action
     */
    private void sendPathPacket(byte[] payload, NodeConnectorRef ingress, Action action) {
        LOG.info("Maple sendPathPacket is invoked");
        /* Get Termination Point Ids from Links of a path*/
        Path r = (Path)action;
        List<String> linkList = r.links;
        List<TpId> tpIdList = new ArrayList<TpId>();
        for (String link: linkList) {
            TpId srcIpId = new TpId(r.getSrcTpId(link));
            tpIdList.add(srcIpId);
        }
        TpId lastTpId =  new TpId(r.lastTpId);
        tpIdList.add(lastTpId);
        String ingressNodeIdString = ingress.getValue().firstIdentifierOf(Node.class)
                .firstKeyOf(Node.class, NodeKey.class).getId().getValue();

        /* Transmit packet-out when node id equals node id of ingress*/
        for (TpId tpId: tpIdList) {
            NodeConnectorRef ncf = getNodeConnectorRefFromTpId(tpId);

            String nodeIdString = ncf.getValue().firstIdentifierOf(Node.class)
                    .firstKeyOf(Node.class, NodeKey.class).getId().getValue();
            if (ingressNodeIdString.equals(nodeIdString)) {
                TransmitPacketInput packetout = FlowUtils.createPacketOut(payload, ingress, ncf);
                packetProcessingService.transmitPacket(packetout);
            }
        }
    }

    /**
     * Send flood packet-out message
     *
     * @param payload
     * @param ingress
     */
    private void sendFloodPacket(byte[] payload, NodeConnectorRef ingress) {
        LOG.info("Maple sendFloodPacket is invoked");
        /* Read node of ingress */
        String nodeId = ingress.getValue().firstIdentifierOf(Node.class).firstKeyOf(Node.class, NodeKey.class)
                .getId().getValue();
        InstanceIdentifier<Node> nodeIId = InstanceIdentifier.builder(Nodes.class)
                .child(Node.class, new NodeKey(new NodeId(nodeId))).build();
        com.google.common.base.Optional<Node > node = null;
        try {
            ReadOnlyTransaction rx = fastDataStore.newReadOnlyTransaction();
            node = rx.read(LogicalDatastoreType.OPERATIONAL, nodeIId).get();
        } catch (InterruptedException e) {
            LOG.error("Fast read DataStore failed");
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

        /* Transmit packet-out when node connector is not the ingress */
        List<NodeConnector> ncList = node.get().getNodeConnector();
        for (NodeConnector nc : ncList) {
            NodeConnectorId ncId = nc.getId();
            InstanceIdentifier<NodeConnector> ncII = InstanceIdentifier.builder(Nodes.class)
                    .child(Node.class, new NodeKey(new NodeId(nodeId)))
                    .child(NodeConnector.class, new NodeConnectorKey(ncId)).toInstance();
            NodeConnectorRef ncf = new NodeConnectorRef(ncII);

            String ncIdString = ncf.getValue().firstIdentifierOf(NodeConnector.class)
                    .firstKeyOf(NodeConnector.class, NodeConnectorKey.class).getId().getValue();
            if (!ncIdString.equals(ingress.getValue().firstIdentifierOf(NodeConnector.class)
                    .firstKeyOf(NodeConnector.class, NodeConnectorKey.class).getId().getValue())) {
                TransmitPacketInput input = FlowUtils.createPacketOut(payload, ingress, ncf);
                packetProcessingService.transmitPacket(input);
            }
        }
    }

    /**
     * Install a path by mapleAction, mapleMatch, priority from maple
     *
     * @param inst
     * @param mapleMatch
     * @param priority
     */
    @Override
    public void installPath(Instruction inst, org.maple.core.increment.tracetree.Match mapleMatch, int priority) {
        LOG.info("Maple installPath is invoked");
        RouteAction mapleAction = inst.getRouteAction();
        Map<org.maple.core.increment.tracetree.Match.Field, SetPacketHeaderAction> setPacketHeaderActionMap = inst.getSPHActions();

        if (mapleAction instanceof Path) {
            Path r = (Path) mapleAction;
            List<String> linkList = r.links;
            ;
            LOG.info("Installing a Path");
            /* Handle one flow entry setup case */
            if (linkList.size() == 0) {
                LOG.info("It is just a one-node rule");
                Match match = setODLMatch(mapleMatch);
                TpId lastTpId = new TpId(r.lastTpId);
                FlowId flowId = new FlowId(String.valueOf(flowIdInc.getAndIncrement()));
                Flow flowBody = FlowUtils.createModifiedFlow(match, flowPriority, lastTpId, setPacketHeaderActionMap, flowId);
                NodeConnectorRef lastncref = getNodeConnectorRefFromTpId(lastTpId);
                //NodeId lastNodeId = FlowUtils.convertTpId2NodeId(lastTpId);
                InstanceIdentifier<Node> nodeIId = getNodeIId(lastncref);

                InstanceIdentifier<org.opendaylight.yang.gen.v1.urn.opendaylight.flow.
                        inventory.rev130819.tables.table.Flow> flowIId = setFlowIId(nodeIId, new TableKey(DEFAULT_TABLE_ID), flowId);
                WriteTransaction wx = fastDataStore.newWriteOnlyTransaction();
                wx.put(LogicalDatastoreType.CONFIGURATION, flowIId, flowBody);
                try {
                    wx.submit().checkedGet();
                } catch (TransactionCommitFailedException e) {
                    LOG.error("Transaction failed: {}", e.toString());
                }
                flowInfo.put(new FlowInfoKey(match, nodeIId), flowIId);
            } else {
            /* Handle multiple flow entries of one path case */
            /* Put termination point Ids from link list into tpIdlist */
                List<TpId> tpIdList = new ArrayList<TpId>();
                for (String link : linkList) {
                    String srcString = r.getSrcTpId(link);
                    TpId srcTpId = new TpId(srcString);
                    tpIdList.add(srcTpId);
                }
                LOG.info("Finish reading TpId:{}", tpIdList);
            /* Put node connector references into a map whose key is nodeIdString */
                this.nodeKey2ncrs = new HashMap<String, Set<NodeConnectorRef>>();
                for (TpId tpId : tpIdList) {
                    NodeConnectorRef ncr = getNodeConnectorRefFromTpId(tpId);
                    String nodeIdString = getNodeString(ncr);
                    if (!nodeKey2ncrs.containsKey(nodeIdString)) {
                        Set<NodeConnectorRef> ncrSet = new HashSet<NodeConnectorRef>();
                        ncrSet.add(ncr);
                        nodeKey2ncrs.put(nodeIdString, ncrSet);
                    } else {
                        nodeKey2ncrs.get(nodeIdString).add(ncr);
                    }
                }

            /* Forward multicast flows to each node and keep records in flowInfo */
                for (Map.Entry<String, Set<NodeConnectorRef>> entry : nodeKey2ncrs.entrySet()) {
                    Set<NodeConnectorRef> ncrSet = entry.getValue();
                    List<NodeConnectorRef> tempList = new ArrayList<NodeConnectorRef>();
                    for (NodeConnectorRef ncr : ncrSet) {
                        tempList.add(ncr);
                    }
                    Match multicastMatch = setODLMatch(mapleMatch);
                    FlowId flowId = new FlowId(String.valueOf(flowIdInc.getAndIncrement()));
                    Flow multicastflow = createMulticastFlow(multicastMatch, tempList, priority, flowId);
                    LOG.info("Finish creating multicastflow:{}", multicastflow);

                    InstanceIdentifier<Flow> flowIId = setMulticastPathForOneNode(tempList, flowId);
                    LOG.info("Create maple flowIId successfully");
                    InstanceIdentifier<Node> nodeIId = getNodeIId(tempList.get(0));
                    LOG.info("Create maple nodeIId successfully");
                    WriteTransaction wx = fastDataStore.newWriteOnlyTransaction();
                    LOG.info("New maple WriteTransaction successfully");
                    wx.put(LogicalDatastoreType.CONFIGURATION, flowIId, multicastflow);
                    try {
                        LOG.info("executing multicastflow tx");
                        wx.submit().checkedGet();
                    } catch (TransactionCommitFailedException e) {
                        LOG.error("Transaction failed: {}", e.toString());
                    }
                    LOG.info("Finish putting multicastflow into data store");
                    flowInfo.put(new FlowInfoKey(multicastMatch, nodeIId), flowIId);
                }

            /* handle the last flow entry with modification field */
                TpId lastTpId = new TpId(r.lastTpId);
                NodeConnectorRef lastncr = getNodeConnectorRefFromTpId(lastTpId);
                Rule lastRule = new Rule(mapleMatch, inst);
                installRule(lastRule, lastncr, priority);
            }
        }
    }

    /**
     * Delete a path by mapleAction, mapelMatch
     *
     * @param inst
     * @param mapleMatch
     */
    @Override
    public void deletePath(Instruction inst, org.maple.core.increment.tracetree.Match mapleMatch) {
        Action action = inst.getRouteAction();
        Match macMatch = setODLMatch(mapleMatch);
        if (action instanceof Path) {

            /* Get termination point Id from links */
            Path r = (Path) action;
            List<String> linkList = r.links;
            List<TpId> tpIdList = new ArrayList<TpId>();
            for (String link: linkList) {
                TpId srcIpId = new TpId(r.getSrcTpId(link));
                tpIdList.add(srcIpId);
            }
            TpId lastTpId = new TpId(r.lastTpId);
            tpIdList.add(lastTpId);

            /* Delete rule one by one */
            try {
                for (TpId tpId : tpIdList) {
                    InstanceIdentifier<Node> nodeIId = setNodeIId(convertTpId2NodeId(tpId));
                    FlowInfoKey flowInfoKey = new FlowInfoKey(macMatch, nodeIId);
                    InstanceIdentifier<Flow> flowIId = flowInfo.get(flowInfoKey);
                    WriteTransaction wx = fastDataStore.newWriteOnlyTransaction();
                    wx.delete(LogicalDatastoreType.CONFIGURATION, flowIId);
                    try {
                        wx.submit().checkedGet();
                    } catch (TransactionCommitFailedException e){
                        LOG.error("Transaction failed: {}", e.toString());
                    }
                    flowInfo.remove(flowInfoKey);
                }
            } catch (Exception e) {
                LOG.info("Exception occurs when remove a path: " + e.getMessage());//Comments(Haizhou): change to Log.error();
            }
        }
    }

    /**
     * Install a rule by Rule, nodeConnectorRef and priority
     *
     * @param rule
     * @param nodeConnectorRef
     * @param priority
     */
    @Override
    public void installRule(Rule rule, NodeConnectorRef nodeConnectorRef, int priority) {
        LOG.info("maple installRule is invoked");
        FlowId flowId = new FlowId(String.valueOf(flowIdInc.getAndIncrement()));
        InstanceIdentifier<org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.
                rev130819.tables.table.Flow> flowIId = createFlowIId(nodeConnectorRef, new TableKey(DEFAULT_TABLE_ID), flowId);
        LOG.info("maple installRule flowIId is :{}", flowIId);
        Match odlMatch = setODLMatch(rule.match);
        Flow flowBody = null;

        if (rule.inst.getRouteAction() instanceof Punt) {

            Uri controllerPort = new Uri(OutputPortValues.CONTROLLER.toString());
            flowBody = createFlow(flowTableId, priority, odlMatch, controllerPort, flowId);
            LOG.info("maple installRule Punt flowBody is :{}", flowBody);

        } else if (rule.inst.getRouteAction() instanceof Flood) {

            Uri flood = new Uri(OutputPortValues.FLOOD.toString());
            flowBody = createFlow(flowTableId, priority, odlMatch, flood, flowId);

            LOG.info("maple installRule Flood flowBody is :{}", flowBody);
        } else if (rule.inst.getRouteAction() instanceof Path) {

            Uri destPortUri = nodeConnectorRef.getValue().firstKeyOf(NodeConnector.class, NodeConnectorKey.class).getId();
            flowBody = createModifiedFlow(odlMatch, priority, destPortUri, rule.inst.getSPHActions(), flowId);

            LOG.info("maple installRule modified flowBody is :{}", flowBody);
        }

        InstanceIdentifier<Node> nodeIId = getNodeIId(nodeConnectorRef);
        LOG.info("installRule nodeIId is :{}", nodeIId);
        WriteTransaction wx = fastDataStore.newWriteOnlyTransaction();
        wx.put(LogicalDatastoreType.CONFIGURATION, flowIId, flowBody);
        try {
            LOG.info("executing install rule wx");
            wx.submit().checkedGet();
        } catch (TransactionCommitFailedException e){
            LOG.error("Transaction failed: {}", e.toString());
        }
        LOG.info("Finish putting rule into data store");
        flowInfo.put(new FlowInfoKey(odlMatch, nodeIId), flowIId);
    }

    /**
     * Delete a rule by Rule, inPort
     *
     * @param rule
     * @param inPort
     */
    @Override
    public void deleteRule(Rule rule, NodeConnectorRef inPort) {
        org.maple.core.increment.tracetree.Match mapleMatch = rule.match;
        Match macMatch = setODLMatch(mapleMatch);
        try {
            InstanceIdentifier<Node> nodeIId = getNodeIId(inPort);
            FlowInfoKey key = new FlowInfoKey(macMatch, nodeIId);
            if (flowInfo.containsKey(key)) {
                InstanceIdentifier<Flow> flowIId = flowInfo.get(key);
                WriteTransaction wx = fastDataStore.newWriteOnlyTransaction();
                wx.delete(LogicalDatastoreType.CONFIGURATION, flowIId);
                try {
                    wx.submit().checkedGet();
                } catch (TransactionCommitFailedException e){
                    LOG.error("Transaction failed: {}", e.toString());
                }
                flowInfo.remove(key);
            } else {
                LOG.info("There isn't this rule at all");
            }
        } catch (Exception e) {
            LOG.info("Exception occurs when remove a path: " + e.getMessage());//Comments(Haizhou): change to Log.error();
        }
    }

    /**
     * Delete all rules
     */
    private void deleteAllRule() {
        InventoryReader ireader = new InventoryReader();
        Topology topo = (Topology) ireader.readData("/root/network-topology/topology");
        List<org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns
                .yang.network.topology.rev131021.network.topology
                .topology.Node> nodes = topo.getNode();
        for(org.opendaylight.yang.gen.v1.urn.tbd.params.xml.ns
                .yang.network.topology.rev131021.network.topology
                .topology.Node node: nodes){
            org.opendaylight.yang.gen.v1.urn.tbd
                    .params.xml.ns.yang.network.topology
                    .rev131021.NodeId nodeId = node.getNodeId();
            InstanceIdentifier<Node> nodeIId = setNodeIId(nodeId);
            InstanceIdentifier<Table> tableIId = setTableIId(nodeIId, new TableKey(DEFAULT_TABLE_ID));
            WriteTransaction wx = fastDataStore.newWriteOnlyTransaction();
            wx.delete(LogicalDatastoreType.CONFIGURATION, tableIId);
            try {
                wx.submit().checkedGet();
            } catch (TransactionCommitFailedException e){
                LOG.error("Transaction failed: {}", e.toString());
            }
        }
        flowInfo.clear();
    }
}
